# Правила и добри практики за писане на код

Този документ описва основните правила и принципи, които следваме при разработката на проекта, с цел поддържане на чист, четим и лесен за поддръжка код.

## 1. Принцип на единствената отговорност (Single Responsibility Principle - SRP)

**Всеки компонент/файл трябва да има една единствена, ясно дефинирана отговорност.**

Големите файлове с над 1000 реда код почти винаги нарушават този принцип. Вместо да създаваме един огромен компонент, който прави всичко, ние го разделяме на по-малки, фокусирани компоненти.

**Пример:** Вместо един `ProductsPage.tsx`, който съдържа логика за филтри, списък и форма за редакция, ние го разделяме на:
- `ProductList.tsx` (показва таблицата с продукти)
- `ProductForm.tsx` (форма за създаване/редакция)
- `ProductFilters.tsx` (панел с филтри)
- `ProductsPage.tsx` (основен компонент, който управлява кой от горните да се покаже)

## 2. Размер на файловете

Стремим се файловете с компоненти да не надвишават **300-400 реда код**. Ако един файл започне да става по-голям, това е силен индикатор, че трябва да бъде разделен (рефакториран) на по-малки части.

## 3. Файлова структура

-   **Преизползваеми компоненти:** Компоненти, които се използват на много различни места в приложението (като `ToggleSwitch`, `SearchableMultiSelect`, `Icons`), трябва да се намират в главната папка `/components`.
-   **Специфични за страница компоненти:** Компоненти, които се използват само в рамките на един по-голям модул/страница, трябва да се намират в под-папка на съответната страница.

    **Пример:**
    Компонентите `TemplateList` и `TemplateForm`, които се използват само от `FacetedNavPage`, се намират в:
    ```
    /pages/catalog/faceted-nav/
    ├── TemplateList.tsx
    └── TemplateForm.tsx
    ```
    А основният файл `FacetedNavPage.tsx` остава в `/pages/catalog/`.

## 4. Именуване

-   **Компоненти:** Имена в `PascalCase` (напр. `ProductList`).
-   **Файлове:** Имена в `PascalCase` (напр. `ProductList.tsx`).
-   **Променливи и функции:** Имена в `camelCase` (напр. `handleSaveProduct`).

## 5. DRY Principle (Don't Repeat Yourself)

Ако виждаш че повтаряш същия код на **3 или повече места**, извади го в отделна функция или компонент.

**Пример:**
- Ако имаш 3 различни форми, които използват една и съща логика за валидация, създай `useFormValidation` custom hook.
- Ако имаш повтарящи се API извиквания със същата error handling логика, създай wrapper функция.

## 6. Коментари

-   **Коментирай:** Сложна бизнес логика, неочевидни алгоритми, workarounds за известни проблеми.
-   **НЕ коментирай:** Очевидни неща, които се разбират от името на функцията/променливата.
-   **Предпочитай:** Самообясняващи се имена пред коментари.

**Лош пример:**
```typescript
// Increment counter
counter++;
```

**Добър пример:**
```typescript
// Apply 15% early bird discount if order is placed before 10 AM
if (orderTime.getHours() < 10) {
  discount = totalPrice * 0.15;
}
```

## 7. TypeScript типове

-   **Избягвай `any`** където е възможно. Използвай го само когато наистина е неизбежно.
-   **Дефинирай интерфейси** за API отговори, пропсове на компоненти, сложни обекти.
-   **Използвай types/interfaces** за пропсовете на всички компоненти.
-   **Създавай споделени типове** в `/types` или `/lib/types` за типове използвани на много места.

**Пример:**
```typescript
// ✅ Добре
interface ProductFormProps {
  product?: Product;
  onSubmit: (data: ProductFormData) => Promise<void>;
  mode: 'create' | 'edit';
}

// ❌ Лошо
function ProductForm(props: any) { ... }
```

## 8. Обработка на грешки

-   **Винаги показвай ясни съобщения** при грешки към потребителя.
-   **Логвай грешките** в конзолата за debug (`console.error`).
-   **Използвай try-catch** при async операции.
-   **Не оставяй празни catch блокове** - винаги обработвай или логвай грешката.

**Пример:**
```typescript
try {
  await createProduct(data);
  toast.success('Продуктът е създаден успешно');
} catch (error) {
  console.error('Error creating product:', error);
  toast.error('Неуспешно създаване на продукт');
}
```

Следването на тези прости правила прави кода по-организиран, по-лесен за четене и навигация, и значително улеснява дебъгването и работата в екип.